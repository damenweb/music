<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Админка - Quiz</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root { 
            --gold: #D4AF37;
            --silver: #B0B0B0; --bronze: #A0522D; 
            --dark-bg: #121212; --panel-bg: #1e1e1e; --text-color: #ffffff; 
            --accent: #0078d4; --border: #333333; --danger: #c62828; 
            --answered: #0e63ab; --answered-2: #1b4e82; --skipped: #444444;
            --offline: #000000;
        }
        
        * { box-sizing: border-box;
}
        body { font-family: 'Roboto', sans-serif; background-color: var(--dark-bg); color: var(--text-color); margin: 0;
            display: flex; flex-direction: column; height: 100vh; overflow: hidden; }

        /* LOGIN */
        #login-screen { position: fixed;
            top: 0; left: 0; width: 100%; height: 100%; background: #121212; z-index: 10000; display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .login-box { background: #1e1e1e; padding: 40px; border-radius: 12px; border: 1px solid var(--accent);
            text-align: center; }
        .login-box input { display: block; width: 250px; padding: 12px;
            margin: 20px 0; background: #000; border: 1px solid #444; color: white; text-align: center; border-radius: 4px;
        }
        .btn-login { background: var(--accent); color: white; border: none; padding: 12px 24px;
            cursor: pointer; width: 100%; font-weight: bold; border-radius: 4px; }

        /* TOP BAR */
        .top-bar { height: 40px;
            background: var(--panel-bg); border-bottom: 1px solid var(--border); display: flex; align-items: center; padding: 0 20px; gap: 15px;
        }
        .top-bar input[type="text"] { background: #121212; border: 1px solid #444; color: white;
            padding: 6px; width: 150px; }
        .btn-sm { background: transparent; border: 1px solid var(--border);
            color: #ccc; padding: 5px 12px; cursor: pointer; font-size: 12px; text-transform: uppercase; border-radius: 3px; transition: 0.2s;
        }
        .btn-sm:hover { background: #333; color: white; border-color: #555;
        }
        .btn-active { border-color: var(--accent); color: var(--accent);
        }
        .btn-active:hover { background: rgba(0, 120, 212, 0.1);
        }
        .btn-red { border-color: var(--danger); color: var(--danger);
        }
        .btn-red:hover { background: rgba(198, 40, 40, 0.1);
        }
        
        /* Pause Button Style like Settings */
        .pause-btn { font-weight: bold;
        }
        .pause-btn.paused { background: var(--gold); color: black; border-color: var(--gold); animation: blink 1s infinite;
        }
        @keyframes blink { 50% { opacity: 0.5;
        } }

        /* HEADER INFO */
        .header-info { height: 110px;
            display: flex; align-items: center; justify-content: space-between; padding: 0 40px; border-bottom: 1px solid var(--border); background: #161616;
        }
        .song-counter { font-size: 24px; font-weight: 300; width: 200px;
        }
        .status-display { flex: 1; text-align: center; font-size: 28px; font-weight: bold; letter-spacing: 2px;
            color: var(--accent); text-transform: uppercase; }
        
        /* CIRCULAR TIMER */
        .timer-wrapper { position: relative;
            width: 100px; height: 100px; display: flex; justify-content: center; align-items: center;
        }
        .timer-svg { width: 100px; height: 100px; transform: rotate(-90deg);
        }
        .timer-circle { fill: none; stroke: var(--accent); stroke-width: 6; stroke-dasharray: 283; stroke-dashoffset: 0;
            transition: stroke-dashoffset 1s linear; }
        .timer-text { position: absolute; font-size: 32px; font-family: monospace;
            font-weight: bold; color: white; }

        /* MAIN LAYOUT */
        .main-container { display: flex;
            flex: 1; overflow: hidden; }
        
        /* LEFT CONTROLS */
        .controls-section { width: 25%; justify-content: center; min-height: 50vh; 
            min-width: 320px; border-right: 1px solid var(--border); padding: 20px; display: flex; flex-direction: column; align-items: center; gap: 20px; background: #181818; overflow-y: auto;
        }
        .play-buttons { display: flex; gap: 15px; justify-content: center; width: 100%;
        }
        .btn-play { width: 80px; height: 80px; border-radius: 50%; border: none; font-weight: bold;
            font-size: 30px; color: white; cursor: pointer; transition: transform 0.1s; display: flex; flex-direction: column; align-items: center; justify-content: center;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3); opacity: 0.4; }
        .btn-play:hover { opacity: 0.8;
        }
        .btn-play.active { opacity: 1; outline: 3px solid white; animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7);
        } 70% { box-shadow: 0 0 0 10px rgba(255, 255, 255, 0);
        } 100% { box-shadow: 0 0 0 0 rgba(255, 255, 255, 0);
        } }

        .nav-buttons { display: flex; width: 100%; gap: 10px;
        }
        .btn-nav { flex: 1; padding: 15px 0; background: #333; color: white;
            border: none; border-radius: 4px; cursor: pointer; font-weight: bold; }
        .btn-nav:hover { background: #444;
        }

        /* INFO TABLE (LEFT BOTTOM) */
        .info-table-container { width: 100%;
            margin-top: 50px; background: #222; padding: 10px; border-radius: 8px; border: 1px solid #333;
        }
        .info-table { width: 100%; border-collapse: collapse; font-size: 16px; color: #ccc;
        }
        .info-table th { text-align: center; border-bottom: 1px solid #444; padding: 4px;
            color: #888; }
        .info-table td { padding: 4px; border-bottom: 1px solid #333;
        }
        .info-table tr:last-child td { border-bottom: none;
        }

        /* RIGHT TABLE */
        .table-section { width: 75%;
            padding: 0; overflow-y: auto; background: var(--panel-bg); }
        .unified-table { width: 100%; border-collapse: collapse;
            font-size: 16px; }
        .unified-table th { background: #252525; position: sticky; top: 0;
            padding: 6px; font-size: 18px; text-align: center; border-bottom: 2px solid #444; z-index: 10; font-weight: 500; color: #aaa;
        }
        .unified-table td { padding: 4px 12px 4px 12px; border-bottom: 1px solid #333; vertical-align: middle;
        }
        
        /* Player Row States */
        .player-row { background: #1e1e1e;
            transition: background 0.3s; }
        .player-row.offline { opacity: 0.5;
        }
        .player-row.answered { background: var(--answered) !important; opacity: 1;
        }
        .player-row.skipped { background: var(--skipped) !important; opacity: 0.7;
        }
        .player-row.done-song { background: #3e2723 !important; opacity: 0.6;
        } /* Skipped Song */

        .player-score { font-weight: bold; font-size: 16px; color: var(--gold);
        }
        
        /* ANSWER CELL STYLES */
        .ans-cell { min-width: 150px;
            position: relative; }
        
        /* Hiding answers securely */
        .ans-block { display: block;
            margin-bottom: 0px; padding: 0px; border-radius: 4px; min-height: 24px; font-weight: 500;
        }
        .ans-block.hidden-text { 
            background: #444;
            color: #444; /* Text matches bg */
            user-select: none;
            overflow: hidden; 
            white-space: nowrap;
            width: 100%;
        }
        
        .eval-actions { display: flex;
            gap: 4px; justify-content: center; align-items: center; }
        .btn-eval { padding: 4px 8px;
            border: none; border-radius: 2px; font-size: 12px; font-weight: bold; cursor: pointer; color: white; min-width: 45px; opacity: 0.6; transition: 0.2s;
        }
        .btn-eval:hover { opacity: 1; transform: scale(1.05);
        }
        .btn-eval.selected { opacity: 1; box-shadow: 0 0 5px white;
            border: 1px solid white; }
        
        .be-yes { background: #2e7d32;
        }
        .be-part { background: #f9a825;
        }
        .be-no { background: #c62828;
        }
        .be-undo { background: #555;
        }

        /* SETTINGS OVERLAY */
        #settings-overlay { display: none;
            position: fixed; top: 50px; right: 20px; width: 800px; background: #222; border: 1px solid #444; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            z-index: 5000; padding: 20px; border-radius: 8px; }
        .settings-table { width: 100%; border-collapse: collapse;
            margin-top: 10px; }
        .settings-table th, .settings-table td { padding: 8px;
            border: 1px solid #444; text-align: center; font-size: 13px; }
        .settings-table input { width: 50px;
            background: #111; border: 1px solid #555; color: white; text-align: center; padding: 4px;
        }

        input::-webkit-outer-spin-button, input::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0;
        }
    </style>
</head>
<body>

<div id="login-screen">
    <div class="login-box">
        <h2>Quiz Admin PRO</h2>
        <input type="password" id="admin-password" placeholder="Пароль" onkeydown="if(event.key==='Enter') login()">
        <button class="btn-login" onclick="login()">ВОЙТИ</button>
    </div>
</div>

<input type="file" id="excel-file" hidden accept=".xlsx, .xls">

<div class="top-bar">
    <button class="btn-sm" onclick="document.getElementById('excel-file').click()">Загрузить Excel</button>
    <div style="display:flex; gap:5px;">
        <input type="text" id="gsheets-url" placeholder="Google Sheet CSV URL">
        <button class="btn-sm" onclick="loadFromGSheets()">Load URL</button>
    </div>
    <div style="flex:1"></div>
    <button class="btn-sm" onclick="toggleSettings()">Настройки</button>
    <button id="btn-pause" class="btn-sm pause-btn" onclick="togglePause()">ПАУЗА</button>
    <button class="btn-sm btn-red" onclick="resetGame()">RESET (F5)</button>
</div>

<div class="header-info">
    <div class="song-counter" id="track-counter">Песня 0 / 0</div>
    
    <div class="status-display" id="status-display">ОЖИДАНИЕ</div>

    <div class="timer-wrapper">
        <svg class="timer-svg">
            <circle class="timer-circle" id="timer-circle" cx="50" cy="50" r="45"></circle>
        </svg>
        <div class="timer-text" id="timer-display">00</div>
    </div>
</div>

<div class="main-container">
    
    <div class="controls-section">
        <div class="play-buttons">
            <button id="btn-lvl-0" class="btn-play" style="background:var(--gold)" onclick="manualStart(0)">
                <span>1</span>
            </button>
            <button id="btn-lvl-1" class="btn-play" style="background:var(--silver)" onclick="manualStart(1)">
                <span>2</span>
            </button>
  
            <button id="btn-lvl-2" class="btn-play" style="background:var(--bronze)" onclick="manualStart(2)">
                <span>3</span>
            </button>
        </div>

        <div class="nav-buttons">
            <button class="btn-nav" onclick="changeTrack(-1)">⏮ ПРЕД</button>
            <button class="btn-nav" style="background:var(--accent)" onclick="forceReveal()">ОТВЕТ</button>
           
            <button class="btn-nav" onclick="changeTrack(1)">СЛЕД ⏭</button>
        </div>

        <div class="info-table-container">
            <table class="info-table">
                <thead><tr><th>Раунд</th><th>Артист</th><th>Песня</th><th>Комбо</th></tr></thead>
                <tbody id="info-table-body">
                    </tbody>
             </table>
        </div>

        <div id="settings-overlay">
            <div style="display:flex;
                justify-content:space-between; align-items:center;">
                <h3>Настройки раундов</h3>
                <button class="btn-sm btn-red" onclick="restoreDefaultSettings()">Сбросить на Default</button>
            </div>
            <table class="settings-table">
                <thead>
                    
                <tr><th>LVL</th><th>Длит (сек)</th><th>Таймер (сек)</th><th>Арт. Очки</th><th>Коэф. 1</th><th>Коэф. 2</th><th>Песня Очки</th><th>Коэф. 1</th><th>Коэф. 2</th><th>Комбо</th></tr>
                </thead>
                <tbody id="settings-tbody"></tbody>
            </table>
            <p style="font-size:12px;
                color:#888; margin-top:10px;">* Настройки сохраняются автоматически</p>
        </div>
    </div>

    <div class="table-section">
        <table class="unified-table">
            <thead>
                <tr>
                    <th style="width:18%">Игрок</th>
                    <th style="width:8%">Очки</th>
                    <th style="width:32%">Исполнитель</th>
                    <th style="width:32%">Песня</th>
                    <th style="width:5%">Раунд</th>
                    <th style="width:5%"></th>
                
                </tr>
            </thead>
            <tbody id="players-table-body">
                </tbody>
        </table>
    </div>
</div>

<div id="player-api-container" style="display:none;"><div id="yt-player"></div></div>

<script>
    // --- CONFIG ---
    const S_URL = 'https://gatadttzyeusozvkwvai.supabase.co';
    const S_KEY = 'sb_publishable_cwXp1mw42C6sDXoeszY8sw_lYrAAefY';
    const supabaseClient = supabase.createClient(S_URL, S_KEY);
    // --- DATA MODELS ---
    let playlist = [];
    let currentIndex = 0;
    let ytPlayer;
    // players[login] = { 
    //    totalScore: number, 
    //    lastSeen: timestamp, 
    //    roundData: { 
    //        artAns, songAns, stage, 
    //        status: 'WAIT' | 'ANS' | 'SKIP_HINT' | 'SKIP_SONG',
    //        artScore, songScore 
    //    } 
    // }
    let players = {};
    let onlineUsers = new Set();
    let sortedPlayerLogins = []; // Fixed order for the current round
    
    const DEFAULT_SETTINGS = [
        // Добавлены kArt2 и kSong2 (по умолчанию 0.25)
        { dur: 2.0, timer: 23, pArt: 40, pSong: 60, kArt: 0.75, kArt2: 0.25, kSong: 0.75, kSong2: 0.25, combo: 25 },
        { dur: 5.0, timer: 20, pArt: 24, pSong: 36, kArt: 0.75, kArt2: 0.25, kSong: 0.75, kSong2: 0.25, combo: 25 },
        { dur: 15.0, timer: 10, pArt: 15, pSong: 15, kArt: 0.6, kArt2: 0.2, kSong: 0.6, kSong2: 0.2, combo: 25 }
    ];
    let settings = { levels: JSON.parse(JSON.stringify(DEFAULT_SETTINGS)) };

    // --- RUNTIME VARS ---
    let activeLevel = -1;
    let currentPhase = 'IDLE'; 
    let timerId, playTimeout;
    let isPaused = false;
    let wasPlayingBeforePause = false;
    let timerEndTimestamp = 0; // GLOBAL TIMER END TRACKER

    const TIMER_CIRCLE_C = 283;
    // --- INIT ---
    async function login() {
        const pass = document.getElementById('admin-password').value;
        const { data } = await supabaseClient.from('quiz_users').select('password').eq('username', 'admin').single();
        if (data && data.password === pass) {
            document.getElementById('login-screen').style.display = 'none';
            sessionStorage.setItem('quiz_authorized', 'true');
            initApp();
        } else {
            alert('Неверный пароль');
        }
    }

    if (sessionStorage.getItem('quiz_authorized') === 'true') {
        document.getElementById('login-screen').style.display = 'none';
        initApp();
    }

    async function initApp() {
        await loadSettings();
        await restoreState();
        renderSettings();
        renderInfoTable();
        // If restoring state, we might need to sort initially
        if (sortedPlayerLogins.length === 0) {
             sortedPlayerLogins = Object.keys(players).sort();
        }
        renderTable();
    }

    // --- YOUTUBE API ---
    function onYouTubeIframeAPIReady() {
        ytPlayer = new YT.Player('yt-player', {
            height: '1', width: '1',
            playerVars: { 'autoplay': 0, 'controls': 0, 'disablekb': 1 },
            events: {
                'onReady': 
                (e) => e.target.setVolume(100),
                'onStateChange': onPlayerStateChange
            }
        });
    }

    function onPlayerStateChange(event) {
        if (event.data == YT.PlayerState.PLAYING && currentPhase === 'PRELOAD') {
            currentPhase = 'PLAYING';
            updateStatus("ОЖИДАНИЕ ОТВЕТОВ");
            
            const lvlCfg = settings.levels[activeLevel];
            const totalTime = Math.ceil(lvlCfg.dur) + lvlCfg.timer; 
            
            broadcastTimer(totalTime, `Подсказка ${activeLevel+1}`);
            startInternalTimer(totalTime); // This handles DB update for timer

            clearTimeout(playTimeout);
            playTimeout = setTimeout(() => {
                ytPlayer.pauseVideo();
            }, lvlCfg.dur * 1000);
        }
    }

    // --- GAME LOGIC ---

    function manualStart(lvl) {
        if(isPaused) togglePause();
        startLevelSequence(lvl);
    }

    async function startLevelSequence(lvl) {
        if (!playlist[currentIndex]) return;
        
        stopLogic();
        activeLevel = lvl;
        currentPhase = 'PRELOAD';
        updateStatus("ЗАГРУЗКА...");
        // --- НОВЫЙ БЛОК: Сброс статуса SKIP_HINT ---
        Object.keys(players).forEach(login => {
            const rd = players[login].roundData;
            // Если игрок просто пропустил предыдущую подсказку,
            // возвращаем его в режим ожидания для новой подсказки.
            if (rd.status === 'SKIP_HINT') {
                rd.status = 'WAIT';
            }
        });
        renderTable(); // Обновляем таблицу, чтобы визуально убрать серый фон у игроков
        // ------------------------------------------
        highlightLevelBtn(lvl);
        
        const row = playlist[currentIndex];
        const vid = extractVideoId(row[0] ? row[0].toString() : "");
        const startSec = row[3 + lvl] || 0; 

        // Send settings for this level to players
        const cfg = settings.levels[lvl];
        const levelsInfo = settings.levels.map(l => ({ 
            pArt: l.pArt, pSong: l.pSong, kSong: l.kSong, kSong2: l.kSong2, pArt: l.pArt, kArt: l.kArt, kArt2: l.kArt2, combo: l.combo 
        }));
        await supabaseClient.channel('quiz_chat').send({ 
            type: 'broadcast', event: 'sync_state', 
            payload: { 
                songNum: currentIndex + 1, 
                totalSongs: playlist.length, 
                level: `Подсказка ${lvl+1}`,
            
                allLevels: levelsInfo,
                activeLvlIdx: lvl
            } 
        });

        // Save state so reloaded players see "PRELOAD"
        saveGlobalState();

        if(ytPlayer && vid) ytPlayer.loadVideoById({ videoId: vid, startSeconds: startSec });
    }

    function startInternalTimer(seconds) {
        clearInterval(timerId);
        
        // Save the Absolute End Time
        timerEndTimestamp = Date.now() + (seconds * 1000);
        saveGlobalState(); // Update DB with new timer

        let timerLeft = seconds;
        const timerMax = seconds;
        updateTimerVisual(timerLeft, timerMax);
        timerId = setInterval(() => {
            if(isPaused) return;
            timerLeft--;
            updateTimerVisual(timerLeft, timerMax);
            
            if (timerLeft <= 0) {
                clearInterval(timerId);
              
                handleTimerEnd();
            }
        }, 1000);
    }

    function updateTimerVisual(val, max) {
        document.getElementById('timer-display').innerText = val < 10 ?
        '0'+val : val;
        const offset = max > 0 ? TIMER_CIRCLE_C - (val / max) * TIMER_CIRCLE_C : TIMER_CIRCLE_C;
        document.getElementById('timer-circle').style.strokeDashoffset = offset;
    }

    function handleTimerEnd() {
        broadcastTimer(0, "");
        timerEndTimestamp = 0; // Reset
        console.log('stage 2_1');
        setTimeout(() => {saveGlobalState(); checkAutoProgress(true);}, 500);
        console.log('stage 2_2');
        //saveGlobalState(); 
        //checkAutoProgress(true);
    }

    // Logic for auto-advancing
    function checkAutoProgress(timerExpired) {
        //const pKeys = Object.keys(players).filter(k => onlineUsers.has(k));
        const pKeys = sortedPlayerLogins;
        
        const totalOnline = pKeys.length;

        if (totalOnline === 0) {
            if(timerExpired) nextHintOrReveal();
            return;
        }

        let finishedSong = 0; 
        let finishedHint = 0;
        pKeys.forEach(k => {
            const rd = players[k].roundData;
            const isDone = (rd.status === 'ANS' || rd.status === 'SKIP_SONG');
            
            if (isDone) finishedSong++;
            if (isDone || rd.status === 'SKIP_HINT') finishedHint++;
        });
        // 1. Все завершили ПЕСНЮ (ответили или сдались) -> Раскрываем
        if (finishedSong >= totalOnline) {
            forceReveal();
            return;
        }

        // 2. Все пропустили ПОДСКАЗКУ (или ответили) -> К следующей подсказке
        if (finishedHint >= totalOnline) {
            nextHintOrReveal();
            return;
        }

        // 3. Таймер истек
        if (timerExpired) {
            nextHintOrReveal();
        }
    }

    function nextHintOrReveal() {
        if (currentPhase === 'REVEALED') return;
        // Защита от двойного срабатывания

        if (activeLevel >= 0 && activeLevel < 2) {
            stopLogic();
            console.log('VOT TUT');
            // Задержка в 500мс, чтобы Supabase успел обработать статусы и игроки увидели переход
            setTimeout(() => startLevelSequence(activeLevel + 1), 500);
        } else {
            forceReveal();
        }
    }

    async function forceReveal() {
        stopLogic();
        currentPhase = 'REVEALED';
        activeLevel = -1;
        timerEndTimestamp = 0;
        highlightLevelBtn(-1);
        broadcastTimer(0, "");
        
        const row = playlist[currentIndex];
        const art = row[1] || "???";
        const sng = row[2] || "???";
        const fullAns = `${art} — ${sng}`;
        updateStatus(fullAns);
        // Broadcast Reveal to players
        await supabaseClient.channel('quiz_chat').send({ 
            type: 'broadcast', event: 'reveal_answer', 
            payload: { answer: fullAns } 
        });
        saveGlobalState();
        renderTable(); 
    }

    // --- CONTROLS ---

    function togglePause() {
        const btn = document.getElementById('btn-pause');
        isPaused = !isPaused;
        btn.classList.toggle('paused', isPaused);
        
        if (isPaused) {
            wasPlayingBeforePause = (ytPlayer && ytPlayer.getPlayerState() === YT.PlayerState.PLAYING);
            if(ytPlayer) ytPlayer.pauseVideo();
            // Pause timer end time shift logic could be complex, 
            // for now, pause stops visual decrement but timestamp remains.
            // (Simplified for MVP: Resume might jump time, but acceptable)
        } else {
            if (currentPhase === 'PLAYING' && wasPlayingBeforePause) {
                ytPlayer.playVideo();
            }
        }
        supabaseClient.channel('quiz_chat').send({ type: 'broadcast', event: 'game_paused', payload: { paused: isPaused } });
    }

    function stopLogic() {
        clearTimeout(playTimeout);
        clearInterval(timerId);
        if(ytPlayer) ytPlayer.pauseVideo();
        updateTimerVisual(0, 1);
    }

    async function changeTrack(dir) {
        let n = currentIndex + dir;
        if (n < 0 || n >= playlist.length) return;
        
        // --- COMMIT SCORES & SORT PLAYERS ---
        // Sorting happens HERE, at the transition
        Object.keys(players).forEach(login => {
            const p = players[login];
            const rd = p.roundData;
            let roundTotal = (rd.artScore || 0) + (rd.songScore || 0);
         
            
            // Auto Combo Calculation
            if (rd.status === 'ANS' && rd.stage !== null) {
                const cfg = settings.levels[rd.stage];
                if (rd.artScore > 0 && rd.songScore > 0) {
                   
                 roundTotal += cfg.combo;
                }
            }
            p.totalScore = Number((p.totalScore + roundTotal).toFixed(2));
            
            // Reset round data
            p.roundData = { artAns: null, songAns: null, stage: null, status: 'WAIT', artScore: 0, songScore: 
            0 };
        });
        // Determine Display Order for next round (Sort by Total Score Descending)
        sortedPlayerLogins = Object.keys(players).sort((a,b) => players[b].totalScore - players[a].totalScore);
        stopLogic();
        currentIndex = n;
        activeLevel = -1;
        timerEndTimestamp = 0;
        highlightLevelBtn(-1);
        updateStatus("ОЖИДАНИЕ");
        
        // FIX: Delete with filter > 0 to avoid 400
        await supabaseClient.from('quiz_chat').delete().neq('id', '00000000-0000-0000-0000-000000000000');
        updateTrackDisplay();
        renderTable();
        saveGlobalState();

        // AUTO-PLAY next track if moving forward
        if (dir > 0) {
            setTimeout(() => manualStart(0), 1000);
        }
    }

    function updateTrackDisplay() {
        document.getElementById('track-counter').innerText = `Песня ${playlist.length ?
        currentIndex+1 : 0} / ${playlist.length}`;
    }

    function updateStatus(text) {
        document.getElementById('status-display').innerText = text;
    }

    function highlightLevelBtn(lvl) {
        document.querySelectorAll('.btn-play').forEach(b => b.classList.remove('active'));
        if (lvl >= 0) document.getElementById(`btn-lvl-${lvl}`).classList.add('active');
    }

    function broadcastTimer(sec, lbl) {
        supabaseClient.channel('quiz_chat').send({ type: 'broadcast', event: 'start_timer', payload: { sec, lvl: lbl } });
    }

    // --- DATA HANDLING ---

    document.getElementById('excel-file').addEventListener('change', e => {
        const reader = new FileReader();
        reader.onload = ev => { parseExcel(XLSX.read(ev.target.result, { type: 'binary' })); };
        reader.readAsBinaryString(e.target.files[0]);
    });
    async function loadFromGSheets() {
        const url = document.getElementById('gsheets-url').value;
        if(!url) return;
        try { 
            const r = await fetch(url);
            const t = await r.text(); 
            parseExcel(XLSX.read(t, {type:'string'})); 
        } catch(e){ alert("Ошибка загрузки CSV");
        }
    }

    function parseExcel(wb) {
        const sheet = wb.Sheets[wb.SheetNames[0]];
        const raw = XLSX.utils.sheet_to_json(sheet, {header:1});
        playlist = raw.filter(r => r[0] && r[0].toString().includes('http'));
        currentIndex = 0;
        updateTrackDisplay();
        saveGlobalState();
    }

    function extractVideoId(u) { return u.match(/(?:v=|\/)([0-9A-Za-z_-]{11})/)?.[1]; }

    // --- PLAYER & CHAT LOGIC ---

    const channel = supabaseClient.channel('quiz_chat');
    channel.on('presence', { event: 'sync' }, () => {
        const state = channel.presenceState();
        onlineUsers.clear();
        
        for (const id in state) {
            state[id].forEach(p => {
                const login = p.user; 
                onlineUsers.add(login);
   
                if (!players[login]) {
                    players[login] = { 
                        totalScore: 0, 
                        lastSeen: Date.now(), 
                        roundData: { artAns: null, songAns: null, stage: null, status: 'WAIT', artScore: 0, songScore: 0 }
                    };
                    sortedPlayerLogins.push(login); // Add new player to end of list
        
                } else {
                    players[login].lastSeen = Date.now();
                }
            });
        }
        renderTable();
    }).on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'quiz_chat' }, payload => {
        handleIncomingMessage(payload.new);
    }).subscribe();

    function handleIncomingMessage(data) {
        // format: "Level Login" or "Login"
        // Parsing Login from player_name field
        const parts = data.player_name.split(' ');
        const login = parts.length > 1 ? parts.slice(1).join(' ') : data.player_name;
        // Fallback for simple login
        const safeLogin = players[login] ? login : parts[parts.length-1];
        if (!players[safeLogin]) return;
        const p = players[safeLogin];

        p.lastSeen = Date.now();
        // --- NEW LOGIC: Extract Metadata from Message (Fixes Race Condition) ---
        let rawMsg = data.message;
        let clientStage = null;
        let clientSongNum = null;

        // Regex searches for {{S:5}}{{L:0}} at the start
        const metaRegex = /^\{\{S:(\d+)\}\}\{\{L:(-?\d+)\}\}\s?/;
        const match = rawMsg.match(metaRegex);
        
        if (match) {
            clientSongNum = parseInt(match[1]);
            // e.g. 5
            clientStage = parseInt(match[2]);   // e.g.
            0
            rawMsg = rawMsg.replace(metaRegex, '');
            // Remove metadata from text
        }

        // 1. Prevent Late Answer from Previous Track
        // Player sends songNum (1-based), Admin uses currentIndex (0-based)
        if (clientSongNum !== null && (clientSongNum - 1) !== currentIndex) {
            console.warn(`Late packet ignored: PlayerSong ${clientSongNum} vs AdminSong ${currentIndex + 1}`);
            return; 
        }

        // 2. Determine which Stage to use (Client's claim OR Admin's current)
        // If client sent a stage, use it.
        // Otherwise use activeLevel.
        const effectiveStage = (clientStage !== null) ? clientStage : activeLevel;
        if (rawMsg === "SKIP_SONG") {
            p.roundData.status = 'SKIP_SONG';
        } else if (rawMsg === "SKIP") {
            p.roundData.status = 'SKIP_HINT';
        } else {
            const [art, sng] = rawMsg.split(' | ');
            p.roundData.artAns = art;
            p.roundData.songAns = sng;
            p.roundData.stage = effectiveStage; 
            p.roundData.status = 'ANS';
        }

        renderTable();
        console.log('stage 3');
        checkAutoProgress(false);
    }

    // --- TABLE RENDER & SCORING ---

    function renderTable() {
        const tbody = document.getElementById('players-table-body');
        tbody.innerHTML = '';

        // Use cached sorted order so rows don't jump
        // Filter out deleted players just in case
        const validLogins = sortedPlayerLogins.filter(l => players[l]);
        validLogins.forEach(login => {
            const p = players[login];
            const rd = p.roundData;
            const isOnline = onlineUsers.has(login);
            
            const tr = document.createElement('tr');
            tr.className = 'player-row';
            
            if (!isOnline) tr.classList.add('offline');
            
            if (rd.status === 'ANS') tr.classList.add('answered');
            else if (rd.status === 'SKIP_HINT') tr.classList.add('skipped');
            else if (rd.status === 'SKIP_SONG') tr.classList.add('done-song');

            const isRevealed = currentPhase === 'REVEALED';
            const showContent = isRevealed && rd.status === 
            'ANS';
            
            // Calculate Display Scores
            const lvl = rd.stage !== null ? rd.stage : 0;
            const cfg = settings.levels[lvl];
            
            const as = rd.artScore || 0;
        
            const ss = rd.songScore || 0;
            //let comboBonus = 0;
            //if (rd.status === 'ANS' && as > 0 && ss > 0) comboBonus = cfg.combo;
            //const currentRoundTotal = as + ss + comboBonus;
            let comboBonus = 0;
            if (rd.status === 'ANS' && as > 0 && ss > 0) comboBonus = cfg.combo;
            const currentRoundTotal = Math.floor((as + ss)*(1+comboBonus/100));
            
            const displayScore = Number((p.totalScore + currentRoundTotal).toFixed(2));
            // Generate Buttons
            const genBtns = (type, maxPts, k1, k2) => {
                if (!showContent) return '';
                const currentVal = type === 'art' ? as : ss;
                
                const valFull = Number(maxPts.toFixed(2));
                const valK1 = Number((maxPts * k1).toFixed(2));
                const valK2 = Number((maxPts * (k2 || 0)).toFixed(2));
            
                return `
                <div class="eval-actions" style="flex-wrap: wrap;">
                    <button class="btn-eval be-yes ${currentVal === valFull ? 'selected' : ''}" onclick="setScore('${login}', '${type}', ${valFull})">+${valFull}</button>
                    <button class="btn-eval be-part ${currentVal === valK1 ? 'selected' : ''}" onclick="setScore('${login}', '${type}', ${valK1})">+${valK1}</button>
                    <button class="btn-eval be-part ${currentVal === valK2 ? 'selected' : ''}" style="background:#ce93d8" onclick="setScore('${login}', '${type}', ${valK2})">+${valK2}</button>
                    <button class="btn-eval be-undo" onclick="setScore('${login}', '${type}', 0)">0</button>
                </div>`;
            };
            const artHtml = `<div class="ans-block ${!showContent && rd.status==='ANS' ? 'hidden-text' : ''}">${rd.artAns ||
            (rd.status.includes('SKIP') ? 'SKIP' : '---')}</div>` + genBtns('art', cfg.pArt, cfg.kArt, cfg.kArt2);
            const sngHtml = `<div class="ans-block ${!showContent && rd.status==='ANS' ? 'hidden-text' : ''}">${rd.songAns ||
            (rd.status.includes('SKIP') ? 'SKIP' : '---')}</div>` + genBtns('song', cfg.pSong, cfg.kSong, cfg.kSong2);

            tr.innerHTML = `
                <td align=center style="font-size:18px;"><b>${login}</b> <small style="color:${isOnline?'#2e7d32':'#555'}">●</small></td>
                <!--<td align=center><input type="number" value="${displayScore}" onchange="manualEditTotal('${login}', this.value)" style="width:60px;background:#000;color:#fff;border:1px solid #444;text-align:center;font-size:16px;font-weight:bold"></td>
                -->
                <td align="center"><input type="number" value="${displayScore}" onchange="manualEditTotal('${login}', this.value)" style="width:60px;height:28px;font-size:18px;font-weight:600;text-align:center;background:linear-gradient(180deg,#1e1e1e,#121212);color:#f1f1f1;border:1px solid #333;border-radius:6px;padding:6px 4px;outline:none;box-shadow:inset 0 0 0 1px rgba(255,255,255,0.04),0 1px 2px rgba(0,0,0,0.6);transition:border-color .15s ease,box-shadow .15s ease" onfocus="this.style.borderColor='#5aa9ff';this.style.boxShadow='0 0 0 2px rgba(90,169,255,0.25)'" onblur="this.style.borderColor='#333';this.style.boxShadow='inset 0 0 0 1px rgba(255,255,255,0.04),0 1px 2px rgba(0,0,0,0.6)'"></td>
                <td align=center class="ans-cell">${artHtml}</td>
                <td align=center class="ans-cell">${sngHtml}</td>
          
                <td align=center style="text-align:center">${rd.stage!==null ?
                (rd.stage+1) : '-'}</td>
                <td align=center style="text-align:center"><button onclick="removePlayer('${login}')" style="color:#c62828;border:none;background:none;font-weight:bold;cursor:pointer">❌</button></td>
            `;
            tbody.appendChild(tr);
        });
    }

    function setScore(login, type, val) {
        val = parseFloat(val);
        if (type === 'art') players[login].roundData.artScore = val;
        if (type === 'song') players[login].roundData.songScore = val;
        renderTable();
        saveGlobalState();
    }

    function manualEditTotal(login, val) {
        players[login].totalScore = parseFloat(val);
        players[login].roundData.artScore = 0;
        players[login].roundData.songScore = 0;
        renderTable();
        saveGlobalState();
    }

    function removePlayer(login) {
        if(confirm(`Удалить игрока ${login}?`)) {
            delete players[login];
            sortedPlayerLogins = sortedPlayerLogins.filter(l => l !== login);
            saveGlobalState();
            renderTable();
        }
    }

    // --- SETTINGS & INFO TABLE ---

    function toggleSettings() {
        const el = document.getElementById('settings-overlay');
        el.style.display = el.style.display === 'block' ? 'none' : 'block';
    }

    function renderSettings() {
        const tbody = document.getElementById('settings-tbody');
        tbody.innerHTML = '';
        settings.levels.forEach((lvl, i) => {
            tbody.innerHTML += `
            <tr>
                <td>${i+1}</td>
                <td><input type="number" step="0.5" value="${lvl.dur}" onchange="updateSet(${i},'dur',this.value)"></td>
                <td><input type="number" value="${lvl.timer}" onchange="updateSet(${i},'timer',this.value)"></td>
             
                <td><input type="number" value="${lvl.pArt}" onchange="updateSet(${i},'pArt',this.value)"></td>
                <td><input type="number" step="0.1" value="${lvl.kArt}" onchange="updateSet(${i},'kArt',this.value)"></td>
                <td><input type="number" step="0.1" value="${lvl.kArt2}" onchange="updateSet(${i},'kArt2',this.value)"></td>
                
                <td><input type="number" value="${lvl.pSong}" onchange="updateSet(${i},'pSong',this.value)"></td>
                <td><input type="number" step="0.1" value="${lvl.kSong}" onchange="updateSet(${i},'kSong',this.value)"></td>
                <td><input type="number" step="0.1" value="${lvl.kSong2}" onchange="updateSet(${i},'kSong2',this.value)"></td>
                
                <td><input type="number" value="${lvl.combo}" onchange="updateSet(${i},'combo',this.value)"></td>
            </tr>`;
    
        });
        renderInfoTable();
    }
    
    function renderInfoTable() {
        const tbody = document.getElementById('info-table-body');
        tbody.innerHTML = '';
        settings.levels.forEach((lvl, i) => {
            const art1 = (lvl.pArt * lvl.kArt).toFixed(2);
            const art2 = (lvl.pArt * (lvl.kArt2 || 0)).toFixed(2);
            const sng1 = (lvl.pSong * lvl.kSong).toFixed(2);
            const sng2 = (lvl.pSong * (lvl.kSong2 || 0)).toFixed(2);
            
            tbody.innerHTML += `
                <tr>
                    <td align=center style="font-size:18px;"><b>${i+1}</b></td>
                    <td align=center style="color:var(--gold)"><b>${lvl.pArt}</b><br><small>(${Number(art1)} | ${Number(art2)})</small></td>
                    <td align=center style="color:var(--gold)"><b>${lvl.pSong}</b><br><small>(${Number(sng1)} | ${Number(sng2)})</small></td>
                    <td align=center style="color:var(--gold)"><b>+${lvl.combo}%</b></td>
                </tr>
            `;
        });
    }

    function updateSet(idx, key, val) {
        settings.levels[idx][key] = parseFloat(val);
        saveSettingsToSupabase();
        renderInfoTable();
    }

    async function saveSettingsToSupabase() {
        await supabaseClient.from('quiz_settings').upsert({ id: 1, json_data: settings });
    }
    
    async function restoreDefaultSettings() {
        if(confirm("Сбросить настройки?")) {
            settings.levels = JSON.parse(JSON.stringify(DEFAULT_SETTINGS));
            renderSettings();
            saveSettingsToSupabase();
        }
    }

    async function loadSettings() {
        const { data } = await supabaseClient.from('quiz_settings').select('json_data').eq('id', 1).single();
        if (data && data.json_data) {
            settings = data.json_data;
        }
    }

    // --- PERSISTENCE ---

    let saveTimeout;
    async function saveGlobalState() {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(async () => {
            const cleanPlayers = JSON.parse(JSON.stringify(players));
            const cleanPlaylist = JSON.parse(JSON.stringify(playlist));
            
            const payload = {
                id: 1,
                playlist: cleanPlaylist,
                scores: cleanPlayers, 
                current_index: currentIndex,
                // NEW: Save precise phase info for reloading players
                active_level: activeLevel,
                current_phase: currentPhase,
                timer_end_ts: timerEndTimestamp
            };

            const { error } = await supabaseClient.from('quiz_state').upsert(payload);
            if(error) console.error("Save Error:", error);
        }, 500);
    }

    async function restoreState() {
        const { data } = await supabaseClient.from('quiz_state').select('*').eq('id', 1).single();
        if (data) {
            if (data.playlist) playlist = data.playlist;
            if (data.current_index) currentIndex = data.current_index;
            if (data.scores) players = data.scores;
            // Restore round vars if present
            if (typeof data.active_level !== 'undefined') activeLevel = data.active_level;
            if (data.current_phase) currentPhase = data.current_phase;
            
            Object.keys(players).forEach(k => {
                if(!players[k].roundData) players[k].roundData = { artAns: null, songAns: null, stage: null, status: 'WAIT', artScore: 0, songScore: 0 };
            });
            updateTrackDisplay();
        }
    }

    async function resetGame() {
        if(confirm("Полный сброс (F5)?")) location.reload();
    }

    // REMOVED AUTO-DELETE INTERVAL AS REQUESTED
</script>
<script src="https://www.youtube.com/iframe_api"></script>
</body>
</html>
